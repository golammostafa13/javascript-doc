## 1. **Syntax Errors**

Happens when code is written incorrectly and JS can‚Äôt even run.

```js
// Example 1 - Missing bracket
if (true {
  console.log("Hello");
}

// Example 2 - Wrong keyword
fucntion sayHi() {
  console.log("Hi");
}
```

‚û°Ô∏è **How to explain:**
The browser/Node will stop immediately and throw something like:
`Uncaught SyntaxError: Unexpected token {`

---

## 2. **Reference Errors**

Trying to use a variable/function that doesn‚Äôt exist (or is out of scope).

```js
console.log(name); // ‚ùå ReferenceError: name is not defined

let x = 5;
console.log(y); // ‚ùå ReferenceError: y is not defined
```

‚û°Ô∏è **Tip to s:** Check spelling, check variable scope, and initialization order.

---

## 3. **Type Errors**

Using a value in a way it‚Äôs not meant for.

```js
let num = 5;
num.toUpperCase(); 
// ‚ùå TypeError: num.toUpperCase is not a function

let nothing = null;
console.log(nothing.length); 
// ‚ùå TypeError: Cannot read properties of null
```

‚û°Ô∏è **Tip:** Watch for `null` / `undefined`.

---

## 4. **Range Errors**

Using a number outside allowed range.

```js
let arr = new Array(-1); 
// ‚ùå RangeError: Invalid array length

function recurse() {
  recurse();
}
recurse(); 
// ‚ùå RangeError: Maximum call stack size exceeded
```

‚û°Ô∏è **Tip:** Usually happens with recursion or wrong array sizes.

---

## 5. **Eval Errors** (rare today)

Old error type related to `eval()`. Not super common, but worth mentioning.

```js
// Modern JS engines rarely throw this, but it exists.
eval("hoo==="); // SyntaxError
```

---

## 6. **URI Errors**

Happens with `encodeURI()` / `decodeURI()` if the string is invalid.

```js
decodeURIComponent("%"); 
// ‚ùå URIError: URI malformed
```

---

## 7. **Custom Errors** (when you throw your own)

Encourage them to create meaningful errors.

```js
function divide(a, b) {
  if (b === 0) {
    throw new Error("Cannot divide by zero!");
  }
  return a / b;
}

divide(5, 0); // ‚ùå Error: Cannot divide by zero!
```

---
**`try...catch`** is one of the most useful things to teach because it helps them **control what happens when errors occur** instead of the app crashing.

---

## üîπ Basic Structure

```js
try {
  // Code that might throw an error
} catch (error) {
  // Runs if an error happens
} finally {
  // (Optional) Always runs no matter what
}
```

---

## üîπ Example 1 ‚Äî Catching an error

```js
try {
  let num = 10;
  console.log(num.toUpperCase()); // ‚ùå TypeError
  console.log("This line won't run"); 
} catch (err) {
  console.log("Error caught:", err.message);
}

console.log("Code continues... ‚úÖ");
```

**Execution flow**:

1. Code inside `try` runs.
2. If an error happens ‚Üí jump immediately to `catch`.
3. Code after the error line is skipped.
4. Program continues after `catch`.

---

## üîπ Example 2 ‚Äî With `finally`

```js
try {
  console.log("Step 1: Run try block");
  throw new Error("Something went wrong!");
} catch (err) {
  console.log("Step 2: Error caught:", err.message);
} finally {
  console.log("Step 3: Finally always runs");
}
```

**Output:**

```
Step 1: Run try block
Step 2: Error caught: Something went wrong!
Step 3: Finally always runs
```

‚úÖ `finally` is useful for cleanup tasks (like closing a DB connection, clearing timers, etc.).

---

## üîπ Example 3 ‚Äî No error happens

```js
try {
  console.log("All good here! ‚úÖ");
} catch (err) {
  console.log("This won't run, no error occurred");
} finally {
  console.log("Finally still runs");
}
```

---

## üîπ Example 4 ‚Äî Throwing custom errors

```js
function divide(a, b) {
  try {
    if (b === 0) {
      throw new Error("Can't divide by zero!");
    }
    return a / b;
  } catch (err) {
    console.log("Caught error:", err.message);
  }
}

console.log(divide(10, 2)); // 5
console.log(divide(10, 0)); // ‚ùå "Caught error: Can't divide by zero!"
```
