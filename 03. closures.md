A **closure** is formed when an inner function remembers the variables from its **outer function's scope**, even after the outer function has finished executing.

---

### ✅ **Example: `accountBalance` with Closure**

```js
function createAccount(initialBalance) {
  let balance = initialBalance; // Private variable

  return {
    deposit(amount) {
      balance += amount;
      console.log(`Deposited: ${amount}. Current Balance: ${balance}`);
    },
    withdraw(amount) {
      if (amount <= balance) {
        balance -= amount;
        console.log(`Withdrew: ${amount}. Current Balance: ${balance}`);
      } else {
        console.log(`Insufficient funds!`);
      }
    },
    getBalance() {
      return balance;
    }
  };
}

const myAccount = createAccount(1000);
myAccount.deposit(500);  // Deposited: 500. Current Balance: 1500
console.log(myAccount.getBalance()); // 1500
```

✅ Here:

* `balance` is **private** (cannot be accessed directly from outside).
* The returned object functions (`deposit`, `withdraw`, `getBalance`) **form closures over balance**.

---

## ✅ **When to Use Closures**

1. **Data Privacy / Encapsulation**

   * Hide implementation details.
   * Example: Banking system, authentication token storage.

2. **Maintain State Without Global Variables**

   * Avoid polluting global scope.
   * Example: Counters, settings, configurations.

3. **Functional Programming Patterns**

   * Currying, partial application, decorators.

4. **Callbacks and Event Handlers**

   * Remember values when an event occurs later.

---

### ✅ **Good Use Case**

```js
function makeCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

## ❌ **When NOT to Use Closures**

1. **Memory-Heavy Scenarios**

   * Closures keep references to outer scope variables, which can cause **memory leaks** if not handled properly.
   * Example: Keeping huge data structures in a closure unnecessarily.

2. **When Simpler Solutions Exist**

   * If state can be managed by classes or simple objects, prefer those for clarity.

3. **In Loops without Proper Scope**

   * Common bug:

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Prints 3, 3, 3 because all closures share same i
```

✔ Fix:

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// Prints 0, 1, 2
```

4. **Performance-Critical Code**

   * Extra closures can increase GC complexity and CPU overhead if used inside tight loops.

---

## ✅ **Quick Rule of Thumb**

* **Use closures when you need private state or to remember context**.
* **Avoid when:**

  * You don't need data hiding.
  * You can achieve the same via class fields or module-level constants.
  * Performance and memory optimization are critical.
