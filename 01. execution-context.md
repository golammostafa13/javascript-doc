**An Execution Context is a container that holds information about the environment where the current JavaScript code is being evaluated and executed.**

There are two main types of execution context:

* **Global Execution Context (GEC)** ‚Äì Created when the JS engine starts executing your file.
* **Function Execution Context (FEC)** ‚Äì Created whenever a function is called.

---

### üîπ How JavaScript Executes Code

JavaScript uses something called the **Call Stack** to manage execution contexts.

* When your program starts, the **Global Execution Context** is created and pushed into the stack.
* Every time you call a function, a **new Function Execution Context** is created and added on top of the stack.
* When the function finishes, its context is removed from the stack.

---

## ‚úÖ Example 1: Basic Execution Context

```javascript
var x = 10;

function greet() {
  var message = "Hello!";
  console.log(message);
}

greet();
console.log(x);
```

---

### üîç Step by Step:

1. **Global Execution Context is created**

   * `x` ‚Üí undefined (due to hoisting)
   * `greet` ‚Üí function reference

2. **Memory Phase (Hoisting)**

   * `x` is stored as `undefined`
   * `greet` is stored as function

3. **Execution Phase**

   * `x = 10`
   * `greet()` is called ‚Üí creates **Function Execution Context**
   * Inside `greet` ‚Üí `message = "Hello!"` ‚Üí print `"Hello!"`
   * After function finishes, its context is popped off the stack

4. Finally, `console.log(x)` ‚Üí `10`

---

### üìä Diagram of Call Stack

```
CALL STACK:
---------------
| greet() FEC |
---------------
| Global EC   |
---------------
```

*(When greet() is called)*

And after greet finishes:

```
CALL STACK:
---------------
| Global EC   |
---------------
```

---

## ‚úÖ How Execution Context is Structured?

Each Execution Context has **3 main parts**:

1. **Variable Environment** ‚Üí Stores variables and function declarations.
2. **Lexical Environment** ‚Üí Manages scope and references.
3. **This Binding** ‚Üí Defines the value of `this`.

---

### üîπ Example 2: Nested Functions & Scope

```javascript
function outer() {
  var outerVar = "I am outer";
  
  function inner() {
    console.log(outerVar);
  }
  
  inner();
}

outer();
```

Here:

* Global EC ‚Üí contains `outer`
* When `outer()` runs ‚Üí creates **FEC for outer**
* When `inner()` runs ‚Üí creates **FEC for inner**

**Inner function** has access to `outerVar` because of **Lexical Environment** ‚Üí This is how **closures** work!


