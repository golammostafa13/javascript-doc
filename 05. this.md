The `this` keyword in JavaScript often confuses beginners and even experienced developers because its value **depends on how a function is called, not where it’s defined**. In this guide, we’ll cover **all possible cases of `this`**, strict mode differences, and how **arrow functions vs normal functions** behave.

---

## ✅ **What is `this`?**

* `this` refers to the **execution context** of a function.
* Its value is **determined at runtime** based on how the function is **invoked**.

---

## ✅ **Case 1: Global Context**

```js
console.log(this);
// Browser: window
// Node.js: global object
```

---

## ✅ **Case 2: Inside a Regular Function**

```js
function show() {
  console.log(this);
}
show(); 
// Browser: window
// Node: global object
```

---

## ✅ **Case 3: Inside an Object Method**

```js
const obj = {
  name: "Golam",
  greet: function() {
    console.log(this.name);
  }
};
obj.greet(); 
// "Golam"
```

✔ `this` points to the **object that calls the method**.

---

## ✅ **Case 4: Inner Function in a Method**

```js
const obj = {
  name: "Golam",
  greet: function() {
    function inner() {
      console.log(this.name);
    }
    inner();
  }
};
obj.greet(); 
// undefined or global object
```

**Why?**
`inner()` is called as a **regular function**, so `this` defaults to the global object.

### ✅ **Fix with Arrow Function**

```js
const obj = {
  name: "Golam",
  greet: function() {
    const inner = () => console.log(this.name);
    inner();
  }
};
obj.greet(); 
// "Golam"
```

---

## ✅ **Case 5: Constructor Function**

```js
function Person(name) {
  this.name = name;
}
const p = new Person("Golam");
console.log(p.name); 
// "Golam"
```

✔ `this` refers to the **newly created object** when using `new`.

---

## ✅ **Case 6: ES6 Class**

```js
class Person {
  constructor(name) {
    this.name = name;
  }
  show() {
    console.log(this.name);
  }
}
const p = new Person("Mostafa");
p.show(); 
// "Mostafa"
```

---

## ✅ **Case 7: Arrow Functions**

Arrow functions **don’t have their own `this`**. They **inherit `this` from the lexical scope**.

```js
const obj = {
  name: "Golam",
  greet: () => console.log(this.name)
};
obj.greet(); 
// undefined (because `this` comes from global scope)
```

---

## ✅ **Case 8: Arrow + Normal Function Combination**

```js
const obj = {
  name: "Golam",
  greet: function() {
    const arrowFn = () => console.log(this.name);
    arrowFn();
  }
};
obj.greet(); 
// "Golam"
```

✔ Arrow inherits `this` from the **normal function** `greet`.

---

## ✅ **Case 9: call(), apply(), bind()**

```js
function greet() {
  console.log(this.name);
}
const obj = { name: "Golam" };

greet.call(obj);  // "Golam"
greet.apply(obj); // "Golam"

const bound = greet.bind(obj);
bound();          // "Golam"
```

---

## ✅ **Case 10: In setTimeout**

```js
setTimeout(function() {
  console.log(this); 
}, 1000);
// window/global

// Fix with arrow function
setTimeout(() => console.log(this), 1000);
// Lexical this
```

---

## ✅ **Case 11: Event Handlers**

```js
document.querySelector("button").addEventListener("click", function() {
  console.log(this); // <button>
});

document.querySelector("button").addEventListener("click", () => {
  console.log(this); // window or outer scope
});
```

---

## ✅ **Case 12: Getter / Setter**

```js
const obj = {
  name: "Golam",
  get info() {
    return this.name;
  }
};
console.log(obj.info); 
// "Golam"
```

---

## ✅ **Strict Mode Impact**

Enable strict mode:

```js
"use strict";
function show() {
  console.log(this);
}
show(); 
// undefined
```
